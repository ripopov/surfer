use eyre::Result;
use std::{
    cell::RefCell,
    collections::{HashMap, VecDeque},
    sync::{Arc, atomic::AtomicBool},
};
use tokio::task::JoinHandle;

use egui::{Pos2, Rect};
use surfer_translation_types::translator::VariableNameInfo;

use crate::{
    CachedDrawData, CanvasState, Channels, WcpClientCapabilities, command_prompt,
    displayed_item::DisplayedItemRef,
    hierarchy::ScopeExpandType,
    message::Message,
    state::UserState,
    table::{TableCacheEntry, TableCacheKey, TableRuntimeState, TableTileId},
    translation::{TranslatorList, all_translators},
    wave_container::VariableRef,
    wave_source::{LoadOptions, LoadProgress},
};

#[cfg(feature = "performance_plot")]
use crate::benchmark::Timing;

pub struct SystemState {
    pub user: UserState,

    /// Which translator to use for each variable
    pub(crate) translators: TranslatorList,
    /// Channels for messages generated by other threads
    pub channels: Channels,

    /// Tracks progress of file/variable loading operations.
    pub(crate) progress_tracker: Option<LoadProgress>,

    /// Buffer for the command input
    pub(crate) command_prompt: command_prompt::CommandPrompt,

    /// The context to egui, we need this to change the visual settings when the config is reloaded
    pub(crate) context: Option<Arc<egui::Context>>,

    /// List of batch messages which will executed as soon as possible
    pub(crate) batch_messages: VecDeque<Message>,
    pub(crate) batch_messages_completed: bool,

    /// The WCP server
    #[allow(unused)]
    pub(crate) wcp_server_thread: Option<JoinHandle<()>>,
    #[allow(unused)]
    pub(crate) wcp_server_address: Option<String>,
    #[allow(unused)]
    pub(crate) wcp_stop_signal: Arc<AtomicBool>,
    #[allow(unused)]
    pub(crate) wcp_running_signal: Arc<AtomicBool>,
    pub(crate) wcp_greeted_signal: Arc<AtomicBool>,
    pub(crate) wcp_client_capabilities: WcpClientCapabilities,

    /// The draw commands for every variable currently selected
    // For performance reasons, these need caching so we have them in a RefCell for interior
    // mutability
    pub(crate) draw_data: RefCell<Vec<Option<CachedDrawData>>>,

    pub(crate) variable_name_info_cache: RefCell<HashMap<VariableRef, Option<VariableNameInfo>>>,

    pub(crate) gesture_start_location: Option<Pos2>,

    pub(crate) measure_start_location: Option<Pos2>,

    // Egui requires a place to store text field content between frames
    pub(crate) url: RefCell<String>,
    pub(crate) command_prompt_text: RefCell<String>,
    pub(crate) last_canvas_rect: RefCell<Option<Rect>>,
    pub(crate) surver_selected_file: RefCell<Option<usize>>,
    pub(crate) surver_load_options: RefCell<LoadOptions>,

    /// These items should be expanded into subfields in the next frame. Cleared after each
    /// frame
    pub(crate) items_to_expand: RefCell<Vec<(DisplayedItemRef, usize)>>,
    /// Character to add to the command prompt if it is visible. This is only needed for
    /// presentations at them moment.
    pub(crate) char_to_add_to_prompt: RefCell<Option<char>>,
    // This item works with the expand scope feature to determine what hierarchys to open
    pub scope_ref_to_expand: RefCell<Option<ScopeExpandType>>,

    // Benchmarking stuff
    /// Invalidate draw commands every frame to make performance comparison easier
    pub(crate) continuous_redraw: bool,
    #[cfg(feature = "performance_plot")]
    pub(crate) rendering_cpu_times: VecDeque<f32>,
    #[cfg(feature = "performance_plot")]
    pub(crate) timing: RefCell<Timing>,

    // Undo and Redo stacks
    pub(crate) undo_stack: Vec<CanvasState>,
    pub(crate) redo_stack: Vec<CanvasState>,

    pub(crate) url_callback: Option<Box<dyn Fn(String) -> Message + Send + 'static>>,

    pub(crate) table_runtime: HashMap<TableTileId, TableRuntimeState>,
    pub(crate) table_inflight: HashMap<TableCacheKey, Arc<TableCacheEntry>>,

    // Only used for testing
    pub(crate) expand_parameter_section: bool,
}

impl SystemState {
    pub fn new() -> Result<SystemState> {
        Self::new_inner(false)
    }

    #[cfg(test)]
    pub(crate) fn new_default_config() -> Result<SystemState> {
        Self::new_inner(true)
    }

    fn new_inner(force_default_config: bool) -> Result<SystemState> {
        let channels = Channels::new();

        // Basic translators that we can load quickly
        let translators = all_translators();

        let result = SystemState {
            user: UserState::new(force_default_config)?,
            translators,
            channels,
            progress_tracker: None,
            command_prompt: Default::default(),
            context: None,
            wcp_server_thread: None,
            wcp_server_address: None,
            wcp_stop_signal: Arc::new(AtomicBool::new(false)),
            wcp_running_signal: Arc::new(AtomicBool::new(false)),
            wcp_greeted_signal: Arc::new(AtomicBool::new(false)),
            wcp_client_capabilities: WcpClientCapabilities::new(),
            gesture_start_location: None,
            measure_start_location: None,
            batch_messages: VecDeque::new(),
            batch_messages_completed: false,
            url: RefCell::new(String::new()),
            command_prompt_text: RefCell::new(String::new()),
            draw_data: RefCell::new(vec![None]),
            variable_name_info_cache: RefCell::new(HashMap::new()),
            last_canvas_rect: RefCell::new(None),

            items_to_expand: RefCell::new(vec![]),
            char_to_add_to_prompt: RefCell::new(None),
            scope_ref_to_expand: RefCell::new(None),
            surver_selected_file: RefCell::new(None),
            surver_load_options: RefCell::new(LoadOptions::Clear),
            expand_parameter_section: false,

            url_callback: None,
            continuous_redraw: false,
            table_runtime: HashMap::new(),
            table_inflight: HashMap::new(),
            #[cfg(feature = "performance_plot")]
            rendering_cpu_times: VecDeque::new(),
            #[cfg(feature = "performance_plot")]
            timing: RefCell::new(Timing::new()),
            undo_stack: vec![],
            redo_stack: vec![],
        };

        Ok(result)
    }
}

impl From<UserState> for SystemState {
    fn from(serializable_state: UserState) -> SystemState {
        let mut state = SystemState::new().unwrap();
        state.user = serializable_state;
        state
    }
}
